import os, re, json, joblib
import numpy as np
import pandas as pd
import streamlit as st
from pathlib import Path
from sklearn.metrics import accuracy_score, classification_report, confusion_matrix

st.set_page_config(page_title="Student Stress â€” ML Demo", layout="wide")

MODELS_DIR = Path(__file__).parent / "models"
FEATURES_PATH = MODELS_DIR / "feature_names.pkl"
TESTSET_PATH  = MODELS_DIR / "test_set.csv"

@st.cache_resource
def load_feature_names():
    return joblib.load(FEATURES_PATH)

@st.cache_resource
def load_models():
    models = {}
    for p in MODELS_DIR.glob("*.pkl"):
        if p.name == "feature_names.pkl":
            continue
        try:
            models[p.stem] = joblib.load(p)
        except Exception as e:
            st.warning(f"Failed to load {p.name}: {e}")
    return models

@st.cache_resource
def load_testset():
    if TESTSET_PATH.exists():
        return pd.read_csv(TESTSET_PATH)
    return None

def sanitized_name(name: str) -> str:
    return re.sub(r"[^A-Za-z0-9_+-]+", " ", name).strip()

# def predict_single(pipe, feature_names):
#     st.subheader("Single Prediction")
#     cols = st.columns(3)
#     values = {}
#     for i, f in enumerate(feature_names):
#         with cols[i % 3]:
#             values[f] = st.number_input(f, value=0.0, format="%.4f")
#     if st.button("Predict", type="primary"):
#         X = pd.DataFrame([values], columns=feature_names)
#         y_pred = pipe.predict(X)[0]
#         st.success(f"Predicted stress level: **{int(y_pred)}**")
#         if hasattr(pipe, "predict_proba"):
#             proba = pipe.predict_proba(X)[0]
#             st.write("Class probabilities:")
#             st.bar_chart(pd.DataFrame(proba, index=[f"class_{i}" for i in range(len(proba))], columns=["prob"]))

def predict_single(pipe, feature_names):
    st.subheader("Single Prediction")
    cols = st.columns(3)
    values = {}
    for i, f in enumerate(feature_names):
        with cols[i % 3]:
            # integer-only input
            values[f] = st.number_input(f, value=0, step=1, format="%d")
    if st.button("Predict", type="primary"):
        X = pd.DataFrame([values], columns=feature_names).astype("int64")
        y_pred = pipe.predict(X)[0]
        st.success(f"Predicted stress level: **{int(y_pred)}**")
        if hasattr(pipe, "predict_proba"):
            proba = pipe.predict_proba(X)[0]
            st.write("Class probabilities:")
            st.bar_chart(pd.DataFrame(proba, index=[f"class_{i}" for i in range(len(proba))], columns=["prob"]))

# def predict_batch(pipe, feature_names):
#     st.subheader("Batch Prediction (CSV upload)")
#     up = st.file_uploader("Upload CSV with the training feature columns", type=["csv"])
#     if up is not None:
#         df = pd.read_csv(up)
#         st.write("Preview:", df.head())
#         try:
#             preds = pipe.predict(df[feature_names])
#             st.write("Predictions (first 20):")
#             st.dataframe(pd.DataFrame({"prediction": preds}).head(20))
#         except Exception as e:
#             st.error(f"Failed to predict: {e}")

def predict_batch(pipe, feature_names):
    st.subheader("Batch Prediction (CSV upload)")
    up = st.file_uploader("Upload CSV with the training feature columns", type=["csv"])
    if up is not None:
        df = pd.read_csv(up)
        st.write("Preview:", df.head())
        # keep only known columns in correct order, coerce to int
        try:
            Xb = df[feature_names].copy()
        except KeyError as e:
            st.error(f"CSV is missing required columns: {e}")
            return
        # coerce to integers (errors='raise' will throw if non-numeric)
        Xb = Xb.astype("int64", errors="raise")
        try:
            preds = pipe.predict(Xb)
            st.write("Predictions (first 20):")
            st.dataframe(pd.DataFrame({"prediction": preds}).head(20))
        except Exception as e:
            st.error(f"Failed to predict: {e}")

def evaluate_on_test(pipe, testset, feature_names, target_col="stress_level"):
    st.subheader("Evaluate on bundled test set")
    y_true = testset[target_col].values
    y_pred = pipe.predict(testset[feature_names])
    acc = accuracy_score(y_true, y_pred)
    st.write(f"**Accuracy:** {acc:.4f}")
    cr = classification_report(y_true, y_pred, output_dict=False)
    st.text("Classification report:\n" + cr)
    cm = confusion_matrix(y_true, y_pred, labels=[0,1,2])
    st.text("Confusion matrix (rows=actual, cols=pred):\n" + str(cm))

def main():
    st.title("ðŸŽ“ Student Stress â€” Model Explorer")

    if not FEATURES_PATH.exists():
        st.error("feature_names.pkl not found in models/. Export from the notebook first.")
        st.stop()

    feature_names = load_feature_names()
    models = load_models()
    testset = load_testset()

    if not models:
        st.warning("No models found in models/. Export from the notebook to populate .pkl files.")
        st.stop()

    names = sorted(models.keys())
    choice = st.selectbox("Choose a model", names, index=0, format_func=sanitized_name)
    pipe = models[choice]

    col1, col2 = st.columns(2)
    with col1:
        predict_single(pipe, feature_names)
    with col2:
        predict_batch(pipe, feature_names)

    st.divider()
    if testset is not None:
        evaluate_on_test(pipe, testset, feature_names)
    else:
        st.info("No test_set.csv bundled. Export it from the notebook to enable onâ€‘app evaluation.")

if __name__ == "__main__":
    main()